**细节指北**
=====
*想到啥写啥，不定期更新，欢迎投稿XD*
-----

#### Chapter 4



* P112 table4.3

表格里也说了%o,%x,%X(八进制数，十六进制数)只能表示`unsigned`无符号的数。

* P104 Listing 4.3：

输入"Serendipity Chance"名和姓后，`strlen()`给出的结果只有"Serendipity"这11个字母，原因是`scanf()`遇到空格会停止，忽略空格后的内容，而不是`strlen()`的问题。参见Chapter 4 Review Questions.

* Magic number 要少出现

就是程序里莫名其妙的数字，越少出现越好。多使用`const`,`#define`来定义一个常数，方便你我他~


>* 黑芝麻是从火龙果里挑的。
>* 白芝麻是从草莓上剥的。
>>* 据说99%的人都不知道
>>>* 看来现代人的生活太优越了。

#### Chapter 3

* 指数形式表示浮点数时，指数部分的有效位数是固定的，不能修改，不同编译器不一样。
> `0.1e+003`的+003

* P83 Underflow

0.1234E-10 除以 10 变成 0.0123E-10这个例子，只是举个栗子...意思是指数部分不能再小了的情况下（最多-10不能-11）除以10，会舍弃指数部分前面的尾数部分，小数点向左移，从而导致下溢。下溢一般在除法中出现。
> 实际上在你的编译器里会变成0.1234E-11

* 书P75表格里十六进制表示char错误！！！

书中表格上面一段话刚写完“用十六进制形式表示字符常量时，反斜杠后面跟一个x或X，再加上1~3位十六进制数字”，图3.5表格就写错了。char类型十六进制应为\x41或者\x041而不是\0x41。


* C语言中没有`unsigned float`

我也是听说的，参考StackOverflow : [Why doesn't C have unsigned floats?](http://stackoverflow.com/questions/512022/why-doesnt-c-have-unsigned-floats)

* `scanf`和`printf`的f是"**format**"即"**使格式化**"

f不是functon

* Q:为啥有浮点数有精度？A:因为浮点数是**离散**的

计算机内部的浮点数并不能被完全精确地表示，而是取最接近的某个数。比如1.0实际上只能表示为0.999999999999987654321（瞎写的），**因为这个数最接近1.0**。  
另外超过`float`和`double`的精度（**有效数字**）后的数字的确存在，但是都不能保证正确。  
> 而`double`就是比`float`更精确，能表示的位数更多。  
> 例如`float`**只有6-7位有效数字**，第8位之后都是假的XD

> `double`有**15-16位有效数字**

* 因为上述原因，我们只能用以下方法判断两个浮点数是否相等：

```c
  fabs(float a - float b) < 1e-8
  //1e8是自选的，一般小数点后8位就行了
```
>* fabs()：取绝对值

而不能直接判断浮点数是否相等：

```c
  float a == float b
  //基本都失败的
```

* 浮点的输入输出格式符：

|浮点输入输出  |float|double|
|---|---|---|
|scanf()|%f|%lf|
|printf()|%f,%e|%f,%e|

**很重要！！！**
