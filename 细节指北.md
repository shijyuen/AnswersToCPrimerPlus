**细节指北**
=====
*想到啥写啥，不定期更新，欢迎投稿XD*
-----

> 自定义的函数：
```c
#include <stdio.h>
int a(int);
int main(void){
	int b = 2;
	a(b);
	printf("%d", b);
	return 0;
}
int a(int b){
	b = b * 2; 
	printf("%d\n", b);
	return b;
}
```
其返回结果为：
```c
4
2
```
由此可见虽然在自定义函数a()内部b的值为4，但是实际上b的值没有变化，依然是2。  


#### Chatper 5
* P163 a++ 和 ++a 的区别  

* P153 7./4.和7./4 的结果为啥一样？
有个东西叫**自动类型转换**：
1. 对于`printf`， 任何小于int 的类型都会转换成int; float会被转换成double。
2. 但是`scanf`不会，输入`short`必须使用%hd。
3. 当运算符两边出现不一致的类型时， 会自动转换成较大的类型
> char, short, int, long, long long  

> int, float, double(从小到大)   

当然之后还会有**强制类型转换**


* P156 运算顺序的问题  
**y = 6 * 12 + 5 * 20**啥顺序？先引用原文：
> 但是，优先级并未规定到底先进行哪一个乘法。C 语言把主动权留给语言的实现者，根据不同的硬件来决定先计算前者还是后者。

> 读者可能会根据乘法从左往右的结合律，认为应该先执行+运算符左边 的乘法。结合律只适用于共享同一运算对象运算符。  

换句话说，每台电脑，编译器都有自己固定的运算顺序。
 



#### Chapter 4

* P123 Listing 4.11 补充一下上课没回答出来的那个问题...  
之前学过`short`类型是2字节(byte)即16比特(bits)，所以`unsigned short`最大能表示2^16=65536，`short`范围则是-32768 ~ +32767(包括0)。  
而程序中想以`%hd`即`short`打印的WORD == 65618， 结果是82(不是想要的结果)， 因为超出其能表示的范围。



* P112 table4.3

表格里也说了%o,%x,%X(八进制数，十六进制数)只能表示`unsigned`无符号的数。

* P104 Listing 4.3：

输入"Serendipity Chance"名和姓后，`strlen()`给出的结果只有"Serendipity"这11个字母，原因是`scanf()`遇到空格会停止，忽略空格后的内容，而不是`strlen()`的问题。参见Chapter 4 Review Questions.

* Magic number 要少出现

就是程序里莫名其妙的数字，越少出现越好。多使用`const`,`#define`来定义一个常数，方便你我他~  
> 中文版里注释说，在C语言中，用const类型限定符声明的是变量，不是常量


>* 黑芝麻是从火龙果里挑的。
>* 白芝麻是从草莓上剥的。
>>* 据说99%的人都不知道
>>>* 看来现代人的生活太优越了。

#### Chapter 3

* 指数形式表示浮点数时，指数部分的有效位数是固定的，不能修改，不同编译器不一样。
> `0.1e+003`的+003

* P83 Underflow

0.1234E-10 除以 10 变成 0.0123E-10这个例子，只是举个栗子...意思是指数部分不能再小了的情况下（最多-10不能-11）除以10，会舍弃指数部分前面的尾数部分，小数点向左移，从而导致下溢。下溢一般在除法中出现。
> 实际上在你的编译器里会变成0.1234E-11

* 书P75表格里十六进制表示char错误！！！

书中表格上面一段话刚写完“用十六进制形式表示字符常量时，反斜杠后面跟一个x或X，再加上1~3位十六进制数字”，图3.5表格就写错了。char类型十六进制应为\x41或者\x041而不是\0x41。


* C语言中没有`unsigned float`

我也是听说的，参考StackOverflow : [Why doesn't C have unsigned floats?](http://stackoverflow.com/questions/512022/why-doesnt-c-have-unsigned-floats)

* `scanf`和`printf`的f是"**format**"即"**使格式化**"

f不是functon

* Q:为啥有浮点数有精度？A:因为浮点数是**离散**的

计算机内部的浮点数并不能被完全精确地表示，而是取最接近的某个数。比如1.0实际上只能表示为0.999999999999987654321（瞎写的），**因为这个数最接近1.0**。  
另外超过`float`和`double`的精度（**有效数字**）后的数字的确存在，但是都不能保证正确。  
> 而`double`就是比`float`更精确，能表示的位数更多。  
> 例如`float`**只有6-7位有效数字**，第8位之后都是假的XD

> `double`有**15-16位有效数字**

* 因为上述原因，我们只能用以下方法判断两个浮点数是否相等：

```c
  fabs(float a - float b) < 1e-8
  //1e8是自选的，一般小数点后8位就行了
```
>* fabs()：取绝对值

而不能直接判断浮点数是否相等：

```c
  float a == float b
  //基本都失败的
```

* 浮点的输入输出格式符：

|浮点输入输出  |float|double|
|---|---|---|
|scanf()|%f|%lf|
|printf()|%f,%e|%f,%e|

**很重要！！！**
